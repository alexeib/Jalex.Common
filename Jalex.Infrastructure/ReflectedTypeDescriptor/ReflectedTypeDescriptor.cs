using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Jalex.Infrastructure.Expressions;
using Jalex.Infrastructure.Repository;
using Jalex.Infrastructure.Utils;

namespace Jalex.Infrastructure.ReflectedTypeDescriptor
{
    internal class ReflectedTypeDescriptor<T> : IReflectedTypeDescriptor<T>
    {
        private readonly Type _type;
        private readonly Action<T, string> _idSetter;
        private readonly Func<T, string> _idGetter;

        private readonly ConcurrentDictionary<string, Func<T, object>> _propNameToGetter = new ConcurrentDictionary<string, Func<T, object>>();

        public string TypeName { get { return _type.Name; } }
        public bool IsIdAutoGenerated { get; private set; }
        public string IdPropertyName { get; private set; }
        public IEnumerable<PropertyInfo> Properties { get; private set; }
        public bool HasClusteredIndices { get; private set; }
        public Expression<Func<T, string>> IdGetterExpression { get; private set; }
        public ParameterExpression TypeParameter { get; private set; }
        public MemberExpression IdPropertyExpression { get; private set; }

        public ReflectedTypeDescriptor()
        {
            _type = typeof(T);

            Properties = _type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
            bool isIdAutoGeneratedLocal;
            IdPropertyName = getIdPropertyName(Properties, out isIdAutoGeneratedLocal);
            IsIdAutoGenerated = isIdAutoGeneratedLocal;

            IdGetterExpression = ExpressionUtils.GetPropertyGetterExpression<T, string>(IdPropertyName);
            _idGetter = IdGetterExpression.Compile();
            _idSetter = ExpressionUtils.GetPropertySetter<T, string>(IdPropertyName);

            TypeParameter = Expression.Parameter(_type);
            IdPropertyExpression = Expression.Property(TypeParameter, IdPropertyName);

            HasClusteredIndices = Properties.Any(prop => prop.GetCustomAttributes(true).Any(a => a is IndexedAttribute && ((IndexedAttribute)a).IsClustered));
        }

        public string GetId(T target)
        {
            Guard.AgainstNull(target, "target");
            return _idGetter(target);
        }

        public void SetId(T target, string id)
        {
            _idSetter(target, id);
        }

        public object GetPropertyValue(string propertyName, T obj)
        {
            Guard.AgainstNull(propertyName, "propertyName");
            Guard.AgainstNull(propertyName, "obj");

            var propGetter = _propNameToGetter.GetOrAdd(propertyName, createGetter);
            var val = propGetter(obj);
            return val;
        }

        private Func<T, object> createGetter(string propertyName)
        {
            var getter = ExpressionUtils.GetPropertyGetter<T, object>(propertyName);
            return getter;
        }

        private static string getIdPropertyName(IEnumerable<PropertyInfo> classProps, out bool isAutoGenerated)
        {
            PropertyInfo idProperty;

            // try to get id propert through attribute annotation first
            // ReSharper disable once PossibleMultipleEnumeration
            var idPropertyAndAttribute = (from prop in classProps
                                          let idAttribute = (IdAttribute)prop.GetCustomAttributes(true).FirstOrDefault(a => a is IdAttribute)
                                          where idAttribute != null
                                          select new { Property = prop, IdAttribute = idAttribute }).FirstOrDefault();

            if (idPropertyAndAttribute != null)
            {
                idProperty = idPropertyAndAttribute.Property;
                isAutoGenerated = idPropertyAndAttribute.IdAttribute.IsAutoGenerated;
            }
            else
            {
                // if no attribute is present, try using convention
                // ReSharper disable once PossibleMultipleEnumeration
                idProperty = classProps.FirstOrDefault(m => RepositoryConstants.IdFieldNames.Contains(m.Name));
                isAutoGenerated = true;
            }

            if (idProperty == null)
            {
                throw new RepositoryException("Id property not found (must be one of " +
                                              string.Join(", ", RepositoryConstants.IdFieldNames) +
                                              "). Alternatively, set a IdAttribute on the key property.");
            }

            string idPropertyName = idProperty.Name;

            if (idProperty.PropertyType != typeof(string))
            {
                throw new RepositoryException("Id property " + idPropertyName + " must be of type string");
            }
            return idPropertyName;
        }        
    }
}
