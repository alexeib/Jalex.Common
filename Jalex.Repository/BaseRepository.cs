using System;
using System.Collections.Generic;
using System.Linq;
using Jalex.Infrastructure.Logging;
using Jalex.Infrastructure.Objects;
using Jalex.Infrastructure.ReflectedTypeDescriptor;
using Jalex.Infrastructure.Repository;
using Jalex.Logging;
using Jalex.Repository.IdProviders;
using Magnum;

namespace Jalex.Repository
{
    public abstract class BaseRepository<T>
    {
        // ReSharper disable once StaticFieldInGenericType
        private static readonly ILogger _staticLogger = LogManager.GetCurrentClassLogger();
        private ILogger _instanceLogger;

        protected readonly IReflectedTypeDescriptor<T> _typeDescriptor;
        protected readonly IIdProvider _idProvider;

        public ILogger Logger
        {
            get { return _instanceLogger ?? _staticLogger; }
            set { _instanceLogger = value; }
        }

        protected BaseRepository(
            IIdProvider idProvider,
            IReflectedTypeDescriptorProvider typeDescriptorProvider)
        {
            Guard.AgainstNull(idProvider, "idProvider");
            Guard.AgainstNull(typeDescriptorProvider, "typeDescriptorProvider");

            _idProvider = idProvider;
            _typeDescriptor = typeDescriptorProvider.GetReflectedTypeDescriptor<T>();
        }

        protected IEnumerable<OperationResult<string>> createResults(
            WriteMode writeMode,
            T[] objects,
            Func<string, bool> doesObjectWithIdExist,
            Func<T, bool> actualAdd)
        {
            ensureObjectIds(writeMode, objects);

            return (from obj in objects 
                    let id = _typeDescriptor.GetId(obj) 
                    select createResult(writeMode, doesObjectWithIdExist, actualAdd, id, obj))
                    .ToList();
        }

        private void ensureObjectIds(WriteMode writeMode, IEnumerable<T> objects)
        {
            HashSet<string> ids = new HashSet<string>();

            foreach (var obj in objects)
            {
                string id = _typeDescriptor.GetId(obj);

                if (id == null && writeMode == WriteMode.Update)
                {
                    throw new InvalidOperationException("Cannot update entity with null id");
                }

                if (_typeDescriptor.IsIdAutoGenerated)
                {
                    id = checkOrGenerateIdForEntity(id, obj);
                }

                if (!ids.Add(id))
                {
                    throw new DuplicateIdException("Attempting to create multiple objects with id " + id + " is not allowed");
                }
            }
        }

        private OperationResult<string> createResult(WriteMode writeMode, Func<string, bool> doesObjectWithIdExist, Func<T, bool> actualAdd, string id, T newObj)
        {
            OperationResult<string> failedResult;
            // ReSharper disable once ConvertIfStatementToConditionalTernaryExpression
            if (!checkIfCanWrite(writeMode, id, doesObjectWithIdExist, out failedResult))
            {
                return failedResult;
            }
            try
            {
                if (actualAdd(newObj))
                {
                    return new OperationResult<string>(true, id);
                }
                return new OperationResult<string>(
                                false,
                                id,
                                Severity.Warning,
                                string.Format("Failed to save {0} {1}", _typeDescriptor.TypeName, id));
            }
            catch (Exception e)
            {
                Logger.ErrorException(e, "Failed to save (mode={0}) {1} (id={2})", writeMode, _typeDescriptor.TypeName, id);
                return new OperationResult<string>(
                                false,
                                id,
                                Severity.Error,
                                string.Format("Failed to add save {0} (id={1})", _typeDescriptor.TypeName, id));

            }
        }

        private bool checkIfCanWrite(WriteMode writeMode, string id, Func<string, bool> doesObjectWithIdExist, out OperationResult<string> failedResult)
        {
            switch (writeMode)
            {
                case WriteMode.Insert:

                    if (!string.IsNullOrEmpty(id) && doesObjectWithIdExist(id))
                    {
                        string message = string.Format("{0} with id {1} already exists", _typeDescriptor.TypeName, id);
                        failedResult = new OperationResult<string>(false, id, Severity.Error, message);
                        Logger.Warn(message);
                        return false;
                    }
                    break;
                case WriteMode.Update:
                    if (string.IsNullOrEmpty(id) || !doesObjectWithIdExist(id))
                    {
                        string message = string.Format("{0} with id {1} does not exist", _typeDescriptor.TypeName, id);
                        failedResult = new OperationResult<string>(false, id, Severity.Error, message);
                        Logger.Warn(message);
                        return false;
                    }
                    break;
                case WriteMode.Upsert:
                    // nothing to check
                    break;
                default:
                    throw new ArgumentOutOfRangeException("writeMode");
            }

            failedResult = null;
            return true;
        }

        private string checkOrGenerateIdForEntity(string id, T newObj)
        {
            if (String.IsNullOrEmpty(id))
            {
                string generatedId = _idProvider.GenerateNewId();
                _typeDescriptor.SetId(newObj, generatedId);
                id = generatedId;
            }
            else if (!_idProvider.IsIdValid(id))
            {
                throw new IdFormatException(id + " is not a valid identifier (validated using " + _idProvider.GetType().Name + ")");
            }

            return id;
        }
    }
}
